// Copyright (c) Zefchain Labs, Inc.
// SPDX-License-Identifier: Apache-2.0

//! Cross-chain batch event update message handler
//! 
//! Handles BatchEventUpdate messages from external game contracts
//! containing player score updates and leaderboard data.

use crate::core::types::*;
use crate::infrastructure::{state::GameHubState, errors::GameHubError};
use linera_sdk::linera_base_types::Timestamp;

/// Handle BatchEventUpdate cross-chain message
/// 
/// This function processes batch event updates sent from external game
/// contracts containing player scores, participation data, and final
/// leaderboard results. It validates the data and processes all updates.
/// 
/// # Arguments
/// * `state` - Mutable reference to the GameHub blockchain state
/// * `event_id` - Unique identifier for the game event
/// * `game_id` - Identifier of the game that sent the update
/// * `player_updates` - Vector of player score updates
/// * `final_leaderboard` - Final leaderboard rankings from the game
/// * `update_timestamp` - When the update was generated by the game
/// 
/// # Returns
/// * `Ok(String)` - Success message with processing statistics
/// * `Err(GameHubError)` - Error if validation fails or processing fails
pub async fn handle_batch_event_update_message(
    state: &mut GameHubState,
    event_id: String,
    game_id: String,
    player_updates: Vec<PlayerEventUpdate>,
    final_leaderboard: Vec<LeaderboardEntry>,
    update_timestamp: Timestamp,
) -> Result<String, GameHubError> {
    // Validate the incoming message data
    state.validate_batch_update_request(&player_updates, &final_leaderboard).await?;
    
    // Process batch player updates (uses existing state method)
    // This method handles registered/unregistered players appropriately
    let result = state.process_batch_player_updates(player_updates, &event_id).await;
    
    // Update leaderboard with final results (uses existing state method)
    if let Err(e) = state.update_leaderboard(&event_id, final_leaderboard).await {
        return Err(GameHubError::DatabaseError);
    }
    
    // Create comprehensive success message for logging
    let success_message = format!(
        "Cross-chain batch update processed for event '{}' from game '{}': {} successful updates, {} failed updates, {} unregistered players processed",
        event_id, 
        game_id, 
        result.successful_updates.len(), 
        result.failed_updates.len(), 
        result.unregistered_players.len()
    );
    
    Ok(success_message)
}

/// Validate batch update message structure
/// 
/// Performs basic structural validation of the BatchEventUpdate message
/// before passing it to the state validation methods.
pub fn validate_batch_update_structure(
    event_id: &str, 
    game_id: &str, 
    player_updates: &[PlayerEventUpdate], 
    final_leaderboard: &[LeaderboardEntry]
) -> Result<(), GameHubError> {
    // Validate required fields are not empty
    if event_id.is_empty() {
        return Err(GameHubError::InvalidInput { 
            field: "event_id".to_string(), 
            reason: "Event ID cannot be empty in batch update".to_string() 
        });
    }
    
    if game_id.is_empty() {
        return Err(GameHubError::InvalidInput { 
            field: "game_id".to_string(), 
            reason: "Game ID cannot be empty in batch update".to_string() 
        });
    }
    
    // Validate we have updates to process
    if player_updates.is_empty() {
        return Err(GameHubError::InvalidInput {
            field: "player_updates".to_string(),
            reason: "Batch update must contain at least one player update".to_string(),
        });
    }
    
    // Validate reasonable batch size (prevent spam/DOS attacks)
    if player_updates.len() > 10_000 {
        return Err(GameHubError::InvalidInput {
            field: "player_updates".to_string(),
            reason: format!("Batch update contains too many updates ({}), maximum is 10,000", player_updates.len()),
        });
    }
    
    // Validate basic structure of each player update
    for (index, update) in player_updates.iter().enumerate() {
        if update.discord_id.is_empty() {
            return Err(GameHubError::InvalidInput {
                field: format!("player_update[{}].discord_id", index),
                reason: "Player Discord ID cannot be empty".to_string(),
            });
        }
    }
    
    // Validate leaderboard structure (if provided)
    for (index, entry) in final_leaderboard.iter().enumerate() {
        if entry.player_discord_id.is_empty() {
            return Err(GameHubError::InvalidInput {
                field: format!("leaderboard[{}].player_discord_id", index),
                reason: "Leaderboard entry Discord ID cannot be empty".to_string(),
            });
        }
        
        if entry.rank == 0 {
            return Err(GameHubError::InvalidInput {
                field: format!("leaderboard[{}].rank", index),
                reason: "Leaderboard rank must be greater than 0".to_string(),
            });
        }
    }
    
    Ok(())
}

/// Generate batch update processing statistics
/// 
/// Helper function to create detailed statistics about batch update processing
/// for logging and monitoring purposes.
pub fn generate_batch_processing_stats(
    result: &BatchUpdateResult,
    event_id: &str,
    game_id: &str,
    total_updates: usize,
) -> String {
    let success_rate = if total_updates > 0 {
        (result.successful_updates.len() * 100) / total_updates
    } else {
        0
    };
    
    format!(
        "Batch processing complete for event '{}' (game: '{}'): Total: {}, Successful: {} ({}%), Failed: {}, Unregistered: {}",
        event_id,
        game_id,
        total_updates,
        result.successful_updates.len(),
        success_rate,
        result.failed_updates.len(),
        result.unregistered_players.len()
    )
}