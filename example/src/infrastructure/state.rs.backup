// Copyright (c) Zefchain Labs, Inc.
// SPDX-License-Identifier: Apache-2.0

use linera_sdk::{
    linera_base_types::Timestamp,
    views::{linera_views, MapView, RegisterView, RootView, SetView, ViewStorageContext},
};

use crate::core::types::*;
use crate::core::validation::player_validation::PlayerValidator;
use crate::infrastructure::errors::GameHubError;


/// The application state.
#[derive(RootView)]
#[view(context = "ViewStorageContext")]
pub struct GameHubState {
    /// Player management (Discord ID -> Player)
    pub players: MapView<String, Player>,

    /// Unregistered player scores (for players who haven't registered yet)
    pub pending_player_data: MapView<String, PendingPlayerData>,

    /// Game management (Game ID -> Game)
    pub games: MapView<String, Game>,

    /// Pending games awaiting approval
    pub pending_games: MapView<String, PendingGame>,

    /// Event tracking (Event ID -> Event)
    pub events: MapView<String, Event>,

    /// GameHub event logging for activity tracking (Event ID -> GameHubEvent)
    pub gamehub_events: MapView<String, GameHubEvent>,

    /// Leaderboards (Event ID -> Rankings)
    pub leaderboards: MapView<String, Vec<LeaderboardEntry>>,

    /// Admin permissions (Discord IDs with admin permissions)
    pub admins: SetView<String>,

    /// Moderator permissions (Discord IDs with moderator permissions)
    pub moderators: SetView<String>,

    /// Scoring configuration
    pub scoring_config: RegisterView<ScoringConfig>,

    /// Audit log for administrative actions (Log ID -> AuditLogEntry)
    pub audit_log: MapView<String, AuditLogEntry>,
}

impl GameHubState {
    /// Initialize contract with default configuration and admin setup
    pub async fn initialize_contract(&mut self, admin_discord_id: &str, timestamp: Timestamp) -> Result<(), GameHubError> {
        // Validate admin Discord ID format
        PlayerValidator::validate_discord_id(admin_discord_id)?;
        
        // Set up default scoring configuration
        self.scoring_config.set(ScoringConfig::default());
        
        // Add the initial admin
        self.admins.insert(admin_discord_id)?;
        
        // Create audit log entry for initialization
        let audit_entry_id = format!("init_{}", timestamp.micros());
        let audit_entry = AuditLogEntry {
            id: audit_entry_id.clone(),
            action: AdminAction::AdminAdded { 
                admin_id: admin_discord_id.to_string() 
            },
            performed_by: "system".to_string(),
            target: Some(admin_discord_id.to_string()),
            timestamp,
            details: Some("Contract initialization".to_string()),
        };
        
        self.audit_log.insert(&audit_entry_id, audit_entry)?;
        
        Ok(())
    }

    /// Get player by Discord ID
    pub async fn get_player(&self, discord_id: &str) -> Option<Player> {
        self.players.get(discord_id).await.ok().flatten()
    }

    /// Check if player exists
    pub async fn player_exists(&self, discord_id: &str) -> bool {
        self.players.get(discord_id).await.ok().flatten().is_some()
    }

    /// Check if player is active (not banned or suspended)
    pub async fn is_player_active(&self, discord_id: &str) -> bool {
        match self.get_player(discord_id).await {
            Some(player) => matches!(player.status, PlayerStatus::Active),
            None => false,
        }
    }

    /// Update player's last activity timestamp
    pub async fn update_player_activity(&mut self, discord_id: &str, timestamp: Timestamp) -> Result<(), GameHubError> {
        let mut player = self.get_player(discord_id).await
            .ok_or(GameHubError::PlayerNotFound)?;
        
        player.last_active = timestamp;
        
        self.players.insert(discord_id, player).map_err(|_| GameHubError::DatabaseError)?;
        
        Ok(())
    }

    /// Register or update player with pending data merging
    pub async fn register_or_update_player(&mut self, discord_id: &str, username: &str, avatar_url: Option<String>, timestamp: Timestamp) -> Result<Player, GameHubError> {
        // Validate input data
        PlayerValidator::validate_complete_player_registration(
            discord_id,
            username,
            avatar_url.as_deref(),
        )?;
        
        // Check if player already exists
        if let Some(mut existing_player) = self.get_player(discord_id).await {
            // Update existing player profile
            existing_player.username = username.to_string();
            existing_player.avatar_url = avatar_url;
            existing_player.last_active = timestamp;
            
            self.players.insert(discord_id, existing_player.clone()).map_err(|_| GameHubError::DatabaseError)?;
            return Ok(existing_player);
        }
        
        // Create new player, check for pending data
        let (total_points, participation_streak) = if let Some(pending_data) = self.pending_player_data.get(discord_id).await.ok().flatten() {
            let streak = self.calculate_streak_from_pending(&pending_data).await;
            (pending_data.total_pending_points, streak)
        } else {
            (0, 0)
        };
        
        let new_player = Player {
            discord_id: discord_id.to_string(),
            username: username.to_string(),
            avatar_url,
            total_points,
            participation_streak,
            best_streak: participation_streak, // Initialize best_streak with current streak
            current_rank: None,
            status: PlayerStatus::Active,
            created_at: timestamp,
            last_active: timestamp,
        };
        
        self.players.insert(discord_id, new_player.clone()).map_err(|_| GameHubError::DatabaseError)?;
        
        // Remove pending data after successful registration
        if self.pending_player_data.get(discord_id).await.ok().flatten().is_some() {
            self.pending_player_data.remove(discord_id).map_err(|_| GameHubError::DatabaseError)?;
        }
        
        Ok(new_player)
    }

    /// Calculate streak from pending event scores
    pub async fn calculate_streak_from_pending(&self, pending_data: &PendingPlayerData) -> u32 {
        // Sort events by participation timestamp
        let mut sorted_events = pending_data.event_scores.clone();
        sorted_events.sort_by_key(|score| score.participation_timestamp);
        
        let mut current_streak = 0;
        let mut last_eligible_timestamp = None;
        
        for event_score in sorted_events {
            if !event_score.streak_eligible {
                continue;
            }
            
            if let Some(last_timestamp) = last_eligible_timestamp {
                // Check if there's a gap that would break the streak
                // For simplicity, assume 7 days max between streak-eligible events
                let time_diff = event_score.participation_timestamp.micros() - last_timestamp;
                let seven_days_micros = 7 * 24 * 60 * 60 * 1_000_000u64;
                
                if time_diff > seven_days_micros {
                    current_streak = 1; // Reset streak
                } else {
                    current_streak += 1;
                }
            } else {
                current_streak = 1; // First eligible event
            }
            
            last_eligible_timestamp = Some(event_score.participation_timestamp.micros());
        }
        
        current_streak
    }

    /// Get player statistics
    pub async fn get_player_stats(&self, discord_id: &str) -> Option<PlayerStats> {
        let player = self.get_player(discord_id).await?;
        
        Some(PlayerStats {
            total_points: player.total_points,
            participation_streak: player.participation_streak,
            current_rank: player.current_rank,
            status: player.status,
            created_at: player.created_at,
            last_active: player.last_active,
        })
    }

    /// Update player profile (username/avatar)
    pub async fn update_player_profile(&mut self, discord_id: &str, username: Option<String>, avatar_url: Option<String>, timestamp: Timestamp) -> Result<(), GameHubError> {
        // Validate input data
        if let Some(ref new_username) = username {
            PlayerValidator::validate_username(new_username)?;
        }
        if let Some(ref new_avatar_url) = avatar_url {
            PlayerValidator::validate_avatar_url(new_avatar_url)?;
        }
        
        // Get existing player
        let mut player = self.get_player(discord_id).await
            .ok_or(GameHubError::PlayerNotFound)?;
        
        // Update fields if provided
        if let Some(new_username) = username {
            player.username = new_username;
        }
        if let Some(new_avatar_url) = avatar_url {
            player.avatar_url = Some(new_avatar_url);
        }
        
        // Update last active timestamp
        player.last_active = timestamp;
        
        // Save updated player
        self.players.insert(discord_id, player).map_err(|_| GameHubError::DatabaseError)?;
        
        // Log the action
        self.add_audit_log_entry(
            AdminAction::PlayerProfileUpdated { 
                player_id: discord_id.to_string() 
            },
            discord_id, // Player updating their own profile
            Some(discord_id),
            Some("Player profile updated"),
            timestamp,
        ).await?;
        
        Ok(())
    }

    /// Check if player has pending data
    pub async fn has_pending_data(&self, discord_id: &str) -> bool {
        self.pending_player_data.get(discord_id).await.ok().flatten().is_some()
    }

    /// Get pending player data
    pub async fn get_pending_data(&self, discord_id: &str) -> Option<PendingPlayerData> {
        self.pending_player_data.get(discord_id).await.ok().flatten()
    }

    /// Get all pending player data using MapView iteration
    pub async fn get_all_pending_player_data(&self) -> Vec<PendingPlayerData> {
        let pending_ids = match self.pending_player_data.indices().await {
            Ok(indices) => indices,
            Err(_) => return Vec::new(),
        };
        
        let mut pending_data = Vec::new();
        for pending_id in pending_ids {
            if let Ok(Some(data)) = self.pending_player_data.get(&pending_id).await {
                pending_data.push(data);
            }
        }
        
        // Sort by first activity (most recent first)
        pending_data.sort_by(|a, b| b.first_activity.micros().cmp(&a.first_activity.micros()));
        pending_data
    }

    /// Calculate event-based points earned for a player (vs total accumulated points)
    pub async fn get_player_event_points(&self, discord_id: &str) -> u64 {
        // Check if player has pending data with individual event scores
        if let Some(pending_data) = self.get_pending_data(discord_id).await {
            // Sum up points from individual events
            pending_data.event_scores.iter().map(|event| event.score).sum()
        } else {
            // For registered players without detailed event history, use total_points
            // In a complete system, we would track individual event participations
            self.get_player(discord_id).await.map(|p| p.total_points).unwrap_or(0)
        }
    }



    // ========== EVENT MANAGEMENT METHODS ==========

    /// Get event by ID
    pub async fn get_event(&self, event_id: &str) -> Option<Event> {
        self.events.get(event_id).await.ok().flatten()
    }

    /// Check if event exists
    pub async fn event_exists(&self, event_id: &str) -> bool {
        self.events.get(event_id).await.ok().flatten().is_some()
    }

    /// Get game ID for event
    pub async fn get_game_id_for_event(&self, event_id: &str) -> Option<String> {
        self.get_event(event_id).await.map(|event| event.game_id)
    }

    /// Get all events with sorting (most recent first for admin interface)
    pub async fn get_all_events(&self) -> Vec<Event> {
        let event_ids = match self.events.indices().await {
            Ok(indices) => indices,
            Err(_) => return Vec::new(),
        };
        
        let mut events = Vec::new();
        for event_id in event_ids {
            if let Ok(Some(event)) = self.events.get(&event_id).await {
                events.push(event);
            }
        }
        
        // Sort events by start time (most recent first)
        events.sort_by(|a, b| b.start_time.micros().cmp(&a.start_time.micros()));
        events
    }

    /// Get all events for a specific game
    pub async fn get_events_by_game(&self, game_id: &str) -> Vec<Event> {
        let event_ids = match self.events.indices().await {
            Ok(indices) => indices,
            Err(_) => return Vec::new(),
        };
        
        let mut events = Vec::new();
        for event_id in event_ids {
            if let Ok(Some(event)) = self.events.get(&event_id).await {
                if event.game_id == game_id {
                    events.push(event);
                }
            }
        }
        
        // Sort events by start time (most recent first)
        events.sort_by(|a, b| b.start_time.micros().cmp(&a.start_time.micros()));
        events
    }

    /// Get events by status
    pub async fn get_events_by_status(&self, status: EventStatus) -> Vec<Event> {
        let event_ids = match self.events.indices().await {
            Ok(indices) => indices,
            Err(_) => return Vec::new(),
        };
        
        let mut events = Vec::new();
        for event_id in event_ids {
            if let Ok(Some(event)) = self.events.get(&event_id).await {
                if event.status == status {
                    events.push(event);
                }
            }
        }
        
        // Sort events by start time (most recent first)
        events.sort_by(|a, b| b.start_time.micros().cmp(&a.start_time.micros()));
        events
    }

// ========== BATCH PROCESSING METHODS ==========

    /// Process single player update
    pub async fn process_player_update(&mut self, update: &PlayerEventUpdate, event_id: &str) -> Result<(), GameHubError> {
        if self.player_exists(&update.discord_id).await {
            self.process_registered_player_update(update, event_id).await
        } else {
            // Add to pending data
            self.add_pending_player_data(update, event_id).await
        }
    }

    /// Process registered player update
    pub async fn process_registered_player_update(&mut self, update: &PlayerEventUpdate, _event_id: &str) -> Result<(), GameHubError> {
        let mut player = self.get_player(&update.discord_id).await
            .ok_or(GameHubError::PlayerNotFound)?;
        
        // Update player's last activity
        player.last_active = update.participation_timestamp;
        
        // Calculate new streak if eligible
        if update.streak_eligible {
            let new_streak = self.calculate_new_streak(&update.discord_id, player.last_active, update.participation_timestamp).await;
            player.participation_streak = new_streak;
            
            // Update best_streak if current streak is higher
            if player.participation_streak > player.best_streak {
                player.best_streak = player.participation_streak;
            }
        }
        
        // Calculate points with streak booster
        let boosted_points = self.calculate_points_with_streak_booster(update.score, player.participation_streak).await;
        player.total_points += boosted_points;
        
        // Save updated player
        self.players.insert(&update.discord_id, player).map_err(|_| GameHubError::DatabaseError)?;
        
        Ok(())
    }

    /// Process batch player updates
    pub async fn process_batch_player_updates(&mut self, updates: Vec<PlayerEventUpdate>, event_id: &str) -> BatchUpdateResult {
        let mut successful_updates = Vec::new();
        let mut failed_updates = Vec::new();
        let mut unregistered_players = Vec::new();
        
        for update in updates {
            match self.process_player_update(&update, event_id).await {
                Ok(()) => {
                    if self.player_exists(&update.discord_id).await {
                        successful_updates.push(update.discord_id);
                    } else {
                        unregistered_players.push(update.discord_id);
                    }
                }
                Err(error) => {
                    failed_updates.push(BatchUpdateError {
                        player_discord_id: update.discord_id,
                        error: error.to_string(),
                    });
                }
            }
        }
        
        BatchUpdateResult {
            successful_updates,
            failed_updates,
            unregistered_players,
        }
    }

    /// Add pending player data
    pub async fn add_pending_player_data(&mut self, update: &PlayerEventUpdate, event_id: &str) -> Result<(), GameHubError> {
        let event_score = EventScore {
            event_id: event_id.to_string(),
            game_id: self.get_game_id_for_event(event_id).await.unwrap_or_else(|| "unknown".to_string()),
            score: update.score,
            participation_timestamp: update.participation_timestamp,
            streak_eligible: update.streak_eligible,
        };
        
        if let Some(mut pending_data) = self.get_pending_data(&update.discord_id).await {
            // Update existing pending data
            pending_data.event_scores.push(event_score);
            pending_data.total_pending_points += update.score;
            
            self.pending_player_data.insert(&update.discord_id, pending_data).map_err(|_| GameHubError::DatabaseError)?;
        } else {
            // Create new pending data
            let pending_data = PendingPlayerData {
                discord_id: update.discord_id.clone(),
                event_scores: vec![event_score],
                total_pending_points: update.score,
                first_activity: update.participation_timestamp,
            };
            
            self.pending_player_data.insert(&update.discord_id, pending_data).map_err(|_| GameHubError::DatabaseError)?;
        }
        
        Ok(())
    }

    // ========== UTILITY METHODS ==========

    /// Validate contract address format
    pub async fn validate_contract_address(&self, contract_address: &str) -> bool {
        // Basic validation - check if it's a valid hex string of appropriate length
        contract_address.len() == 64 && contract_address.chars().all(|c| c.is_ascii_hexdigit())
    }

    /// Get all players using MapView iteration
    pub async fn get_all_players(&self) -> Vec<Player> {
        let player_ids = match self.players.indices().await {
            Ok(indices) => indices,
            Err(_) => return Vec::new(),
        };
        
        let mut players = Vec::new();
        for player_id in player_ids {
            if let Ok(Some(player)) = self.players.get(&player_id).await {
                players.push(player);
            }
        }
        
        // Sort players by total points (highest first) for leaderboard consistency
        players.sort_by(|a, b| b.total_points.cmp(&a.total_points));
        players
    }

    // =====================================
    // Event Management Methods
    // =====================================

    /// Create a new event with admin permission validation
    pub async fn create_event(
        &mut self,
        caller_discord_id: &str,
        game_id: &str,
        name: &str,
        description: &str,
        start_time: Timestamp,
        end_time: Timestamp,
        is_mandatory: bool,
        max_participants: Option<u32>,
        prize_pool: Option<u64>,
        timestamp: Timestamp,
    ) -> Result<Event, GameHubError> {
        // Validate admin permissions
        if let Err(_) = self.validate_admin_permission(caller_discord_id).await {
            return Err(GameHubError::UnauthorizedAction {
                action: "create_event".to_string(),
                discord_id: caller_discord_id.to_string(),
            });
        }

        // Validate that the game exists and is approved
        if !self.is_game_approved(game_id).await {
            return Err(GameHubError::GameNotFound {
                game_id: game_id.to_string(),
            });
        }

        // Validate time parameters
        if start_time >= end_time {
            return Err(GameHubError::InvalidTimeRange);
        }

        // Generate event ID
        let event_id = format!("event_{}_{}", game_id, timestamp.micros());

        // Create the event
        let event = Event {
            id: event_id.clone(),
            game_id: game_id.to_string(),
            name: name.to_string(),
            description: description.to_string(),
            start_time,
            end_time,
            is_mandatory,
            is_mandatory_for_streak: is_mandatory, // Set both fields for compatibility
            grace_period_hours: 24, // Default 24 hour grace period
            max_participants,
            prize_pool,
            participant_count: 0,
            status: EventStatus::Upcoming,
            created_at: timestamp,
            created_by: caller_discord_id.to_string(),
        };

        // Store the event
        self.events.insert(&event_id, event.clone()).map_err(|_| GameHubError::StorageError)?;

        // Add audit log entry
        self.add_audit_log_entry(
            AdminAction::EventCreated { 
                event_id: event_id.clone(),
                game_id: game_id.to_string() 
            },
            caller_discord_id,
            Some(&event_id),
            Some(&format!("Event '{}' created for game {}", name, game_id)),
            timestamp,
        ).await?;

        Ok(event)
    }

    /// Update an existing event with admin permission validation
    pub async fn update_event(
        &mut self,
        caller_discord_id: &str,
        event_id: &str,
        name: Option<&str>,
        description: Option<&str>,
        start_time: Option<Timestamp>,
        end_time: Option<Timestamp>,
        is_mandatory: Option<bool>,
        max_participants: Option<u32>,
        prize_pool: Option<u64>,
        timestamp: Timestamp,
    ) -> Result<(), GameHubError> {
        // Validate admin permissions
        if let Err(_) = self.validate_admin_permission(caller_discord_id).await {
            return Err(GameHubError::UnauthorizedAction {
                action: "update_event".to_string(),
                discord_id: caller_discord_id.to_string(),
            });
        }

        // Get the existing event
        let mut event = self.get_event(event_id).await
            .ok_or_else(|| GameHubError::EventNotFound {
                event_id: event_id.to_string(),
            })?;

        // Update fields if provided
        if let Some(name) = name {
            event.name = name.to_string();
        }
        if let Some(description) = description {
            event.description = description.to_string();
        }
        if let Some(start_time) = start_time {
            event.start_time = start_time;
        }
        if let Some(end_time) = end_time {
            event.end_time = end_time;
        }
        if let Some(is_mandatory) = is_mandatory {
            event.is_mandatory = is_mandatory;
            event.is_mandatory_for_streak = is_mandatory; // Update both fields
        }
        if let Some(max_participants) = max_participants {
            event.max_participants = Some(max_participants);
        }
        if let Some(prize_pool) = prize_pool {
            event.prize_pool = Some(prize_pool);
        }

        // Validate time consistency
        if event.start_time >= event.end_time {
            return Err(GameHubError::InvalidTimeRange);
        }

        // Store the updated event
        self.events.insert(event_id, event).map_err(|_| GameHubError::StorageError)?;

        // Add audit log entry
        self.add_audit_log_entry(
            AdminAction::EventUpdated { event_id: event_id.to_string() },
            caller_discord_id,
            Some(event_id),
            Some(&format!("Event {} updated", event_id)),
            timestamp,
        ).await?;

        Ok(())
    }

    /// Set the mandatory status of an event for streak control
    pub async fn set_event_mandatory(
        &mut self,
        caller_discord_id: &str,
        event_id: &str,
        is_mandatory: bool,
        timestamp: Timestamp,
    ) -> Result<(), GameHubError> {
        // Validate admin permissions
        if let Err(_) = self.validate_admin_permission(caller_discord_id).await {
            return Err(GameHubError::UnauthorizedAction {
                action: "set_event_mandatory".to_string(),
                discord_id: caller_discord_id.to_string(),
            });
        }

        // Get the existing event
        let mut event = self.get_event(event_id).await
            .ok_or_else(|| GameHubError::EventNotFound {
                event_id: event_id.to_string(),
            })?;

        // Update mandatory status
        event.is_mandatory = is_mandatory;
        event.is_mandatory_for_streak = is_mandatory; // Update both fields

        // Store the updated event
        self.events.insert(event_id, event).map_err(|_| GameHubError::StorageError)?;

        // Add audit log entry
        self.add_audit_log_entry(
            AdminAction::EventUpdated { event_id: event_id.to_string() },
            caller_discord_id,
            Some(event_id),
            Some(&format!("Event {} mandatory status set to {}", event_id, is_mandatory)),
            timestamp,
        ).await?;

        Ok(())
    }

    // =====================================
    // CSV Import/Export Methods
    // =====================================

    /// Import leaderboard data from CSV format
    pub async fn import_leaderboard_data(
        &mut self,
        caller_discord_id: &str,
        csv_data: &str,
        timestamp: Timestamp,
    ) -> Result<ImportResult, GameHubError> {
        // Validate admin permissions
        if let Err(_) = self.validate_admin_permission(caller_discord_id).await {
            return Err(GameHubError::UnauthorizedAction {
                action: "import_leaderboard_data".to_string(),
                discord_id: caller_discord_id.to_string(),
            });
        }

        let mut import_result = ImportResult {
            total_processed: 0,
            successful_imports: 0,
            failed_imports: 0,
            errors: Vec::new(),
        };

        // Parse CSV data (expecting format: discord_id,username,total_points,participation_streak)
        let lines: Vec<&str> = csv_data.lines().collect();
        
        // Skip header if present
        let data_lines = if !lines.is_empty() && lines[0].contains("discord_id") {
            &lines[1..]
        } else {
            &lines[..]
        };

        for (line_number, line) in data_lines.iter().enumerate() {
            import_result.total_processed += 1;
            
            let fields: Vec<&str> = line.split(',').map(|s| s.trim()).collect();
            
            if fields.len() < 4 {
                import_result.failed_imports += 1;
                import_result.errors.push(format!("Line {}: Invalid CSV format - expected 4 fields", line_number + 2));
                continue;
            }

            let discord_id = fields[0];
            let username = fields[1];
            let total_points: u64 = match fields[2].parse() {
                Ok(points) => points,
                Err(_) => {
                    import_result.failed_imports += 1;
                    import_result.errors.push(format!("Line {}: Invalid total_points value", line_number + 2));
                    continue;
                }
            };
            let participation_streak: u32 = match fields[3].parse() {
                Ok(streak) => streak,
                Err(_) => {
                    import_result.failed_imports += 1;
                    import_result.errors.push(format!("Line {}: Invalid participation_streak value", line_number + 2));
                    continue;
                }
            };

            // Validate Discord ID format
            if let Err(_) = PlayerValidator::validate_discord_id(discord_id) {
                import_result.failed_imports += 1;
                import_result.errors.push(format!("Line {}: Invalid Discord ID format", line_number + 2));
                continue;
            }

            // Validate username
            if let Err(_) = PlayerValidator::validate_username(username) {
                import_result.failed_imports += 1;
                import_result.errors.push(format!("Line {}: Invalid username", line_number + 2));
                continue;
            }

            // Create or update player
            match self.import_player_data(discord_id, username, total_points, participation_streak, timestamp).await {
                Ok(_) => {
                    import_result.successful_imports += 1;
                },
                Err(error) => {
                    import_result.failed_imports += 1;
                    import_result.errors.push(format!("Line {}: {}", line_number + 2, error));
                }
            }
        }

        // Add audit log entry
        self.add_audit_log_entry(
            AdminAction::CsvDataImported { 
                records_processed: import_result.total_processed,
                successful: import_result.successful_imports,
                failed: import_result.failed_imports 
            },
            caller_discord_id,
            None,
            Some(&format!("CSV import completed: {} processed, {} successful, {} failed", 
                import_result.total_processed, 
                import_result.successful_imports, 
                import_result.failed_imports
            )),
            timestamp,
        ).await?;

        Ok(import_result)
    }

    /// Helper method to import individual player data
    async fn import_player_data(
        &mut self,
        discord_id: &str,
        username: &str,
        total_points: u64,
        participation_streak: u32,
        timestamp: Timestamp,
    ) -> Result<(), GameHubError> {
        // Check if player exists
        if let Some(mut player) = self.get_player(discord_id).await {
            // Update existing player
            player.username = username.to_string();
            player.total_points = total_points;
            player.participation_streak = participation_streak;
            // Update best_streak if imported streak is higher
            if participation_streak > player.best_streak {
                player.best_streak = participation_streak;
            }
            player.last_active = timestamp;
            
            self.players.insert(discord_id, player).map_err(|_| GameHubError::StorageError)?;
        } else {
            // Create new player
            let new_player = Player {
                discord_id: discord_id.to_string(),
                username: username.to_string(),
                avatar_url: None,
                total_points,
                participation_streak,
                best_streak: participation_streak, // Initialize best_streak with current streak
                current_rank: None,
                status: PlayerStatus::Active,
                created_at: timestamp,
                last_active: timestamp,
            };
            
            self.players.insert(discord_id, new_player).map_err(|_| GameHubError::StorageError)?;
        }

        Ok(())
    }

}
